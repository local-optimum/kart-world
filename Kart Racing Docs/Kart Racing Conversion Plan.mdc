# Kart Racing Conversion Plan

## Executive Summary
This document outlines a pragmatic, minimally disruptive plan to convert the existing 3D web-based networked world experience into a kart racing game. The conversion will focus on replacing the default humanoid character logic with kart racing mechanics while leveraging the existing infrastructure for networking, camera management, and collision detection.

## Current System Analysis

### Character Movement System
- **Location**: `packages/3d-web-client-core/src/character/LocalController.ts`
- **Current Behavior**: WASD humanoid movement with gravity, jumping, running, and collision detection
- **Key Features**:
  - Gravity-based physics (-9.8 m/s²)
  - Jump mechanics (single and double jump)
  - Ground/air state detection
  - Collision capsule (0.4m radius, 1.05m height)
  - Movement damping and resistance

### Camera System
- **Location**: `packages/3d-web-client-core/src/camera/CameraManager.ts`
- **Current Behavior**: Third-person orbital camera with mouse/touch controls
- **Key Features**:
  - Distance control (5-25m range)
  - Polar angle constraints (0.25π to 0.95π)
  - Smooth damping and interpolation
  - Collision-aware positioning

### Input System
- **Location**: `packages/3d-web-client-core/src/input/KeyInputManager.ts`
- **Current Mapping**: WASD + Shift (run) + Space (jump)
- **Output**: Direction angle, sprint boolean, jump boolean

### Visual Representation
- **Location**: `packages/3d-web-client-core/src/character/Character.ts`
- **Current**: Humanoid 3D model with animations (idle, jog, sprint, air, double jump)

## Kart Racing Requirements

### Physics Model
- **Acceleration**: Progressive forward/backward acceleration
- **Steering**: Angular velocity based on forward speed
- **Drifting**: Controlled oversteer with momentum preservation
- **Deceleration**: Friction and braking forces
- **Collision**: Bounce/deflection instead of stop

### Control Scheme
- **W/S**: Accelerate/Brake-Reverse
- **A/D**: Steer Left/Right
- **Space**: Drift (handbrake)
- **Shift**: Boost (optional for future)

### Camera Behavior
- **Follow Distance**: Dynamic based on speed (closer when slow, farther when fast)
- **Height**: Elevated position for better track visibility
- **Look-ahead**: Camera anticipates turning direction
- **Smooth Transitions**: Reduced jitter during high-speed maneuvers

## Implementation Plan

### Phase 1: Core Kart Physics (High Priority)

#### 1.1 Create KartController Class
**File**: `packages/3d-web-client-core/src/character/KartController.ts`

**Key Components**:
```typescript
export class KartController {
  // Physics properties
  private velocity: Vector3 = new Vector3();
  private angularVelocity: number = 0;
  private acceleration: number = 0;
  private steeringAngle: number = 0;
  
  // Kart properties
  private maxSpeed: number = 20; // m/s
  private acceleration: number = 8; // m/s²
  private deceleration: number = 12; // m/s²
  private steeringSpeed: number = 2; // rad/s
  private driftFactor: number = 0.95; // momentum preservation
  private frictionCoefficient: number = 0.98;
  
  // State
  private isDrifting: boolean = false;
  private isGrounded: boolean = true;
}
```

**Implementation Tasks**:
- [ ] Replace gravity-based physics with forward/backward acceleration
- [ ] Implement angular velocity for turning
- [ ] Add drift mechanics (reduce lateral friction when Space pressed)
- [ ] Replace capsule collision with box collision (approximate kart dimensions)
- [ ] Maintain ground detection for track adherence

#### 1.2 Modify Input Handling
**File**: `packages/3d-web-client-core/src/input/KeyInputManager.ts`

**Changes**:
- [ ] Update `getOutput()` to return kart-specific controls:
  ```typescript
  {
    throttle: number;     // -1 to 1 (reverse to forward)
    steering: number;     // -1 to 1 (left to right)
    drift: boolean;       // handbrake/drift
    boost: boolean;       // future feature
  }
  ```

#### 1.3 Update CharacterManager Integration
**File**: `packages/3d-web-client-core/src/character/CharacterManager.ts`

**Changes**:
- [ ] Add kart mode flag to configuration
- [ ] Conditionally instantiate KartController instead of LocalController
- [ ] Update spawn positioning (ensure karts spawn on ground)

### Phase 2: Visual Kart Representation (Medium Priority)

#### 2.1 Create KartMesh Class
**File**: `packages/3d-web-client-core/src/character/KartMesh.ts`

**Implementation**:
- [ ] Replace humanoid mesh with cube geometry (temporary)
- [ ] Dimensions: 1.8m length × 1.2m width × 0.8m height
- [ ] Material: Solid color with optional team-based coloring
- [ ] Position: Centered on kart physics body

#### 2.2 Update Character Class
**File**: `packages/3d-web-client-core/src/character/Character.ts`

**Changes**:
- [ ] Add kart mode support
- [ ] Remove humanoid animations
- [ ] Implement simple kart animations (wheel rotation, lean during turns)
- [ ] Update collision bounds

### Phase 3: Camera Adaptations (Medium Priority)

#### 3.1 Implement KartCameraMode
**File**: `packages/3d-web-client-core/src/camera/CameraManager.ts`

**New Features**:
- [ ] Speed-responsive follow distance (5m at rest, 12m at max speed)
- [ ] Elevated camera height (2.5m above kart)
- [ ] Look-ahead prediction based on velocity vector
- [ ] Reduced damping for more responsive tracking
- [ ] Optional stabilization during high-speed turns

**Implementation**:
```typescript
private updateKartCamera(kartPosition: Vector3, kartVelocity: Vector3) {
  const speed = kartVelocity.length();
  const dynamicDistance = remap(speed, 0, 20, 5, 12); // 5m to 12m
  const lookAheadOffset = kartVelocity.clone().normalize().multiplyScalar(2);
  const targetPosition = kartPosition.clone().add(lookAheadOffset);
  
  this.setTarget(targetPosition);
  this.targetDistance = dynamicDistance;
}
```

### Phase 4: Network Synchronization (Low Priority)

#### 4.1 Update Network State
**File**: `packages/3d-web-client-core/src/character/CharacterState.ts`

**Changes**:
- [ ] Add kart-specific state properties:
  ```typescript
  export interface KartState extends CharacterState {
    velocity: { x: number; y: number; z: number };
    angularVelocity: number;
    isDrifting: boolean;
  }
  ```

#### 4.2 Update Networking Logic
**Files**: `packages/3d-web-user-networking/src/*`

**Changes**:
- [ ] Extend network protocol to include kart physics state
- [ ] Update remote character prediction for kart movement
- [ ] Ensure smooth interpolation between network updates

### Phase 5: Configuration and Integration (Low Priority)

#### 5.1 Add Kart Mode Configuration
**File**: `packages/3d-web-experience-client/src/Networked3dWebExperienceClient.ts`

**New Configuration Option**:
```typescript
export interface GameModeConfig {
  mode: 'character' | 'kart';
  kartConfig?: {
    maxSpeed: number;
    acceleration: number;
    steeringSpeed: number;
    driftFactor: number;
  };
}
```

#### 5.2 Update Example Implementation
**File**: `example/multi-user-3d-web-experience/client/src/index.ts`

**Changes**:
- [ ] Add kart mode configuration
- [ ] Remove humanoid animation assets (optional)
- [ ] Update loading screen messaging

## Technical Considerations

### Minimally Disruptive Approach
1. **Preserve Existing APIs**: Maintain compatibility with existing networking and rendering systems
2. **Conditional Logic**: Use feature flags to switch between character and kart modes
3. **Incremental Rollout**: Implement in phases to minimize risk
4. **Backwards Compatibility**: Ensure existing character mode continues to work

### Performance Optimizations
1. **Physics Updates**: Run kart physics at consistent 60fps
2. **Network Efficiency**: Only sync significant state changes
3. **Collision Detection**: Optimize for high-speed collisions
4. **Camera Smoothing**: Balance responsiveness with stability

### Testing Strategy
1. **Unit Tests**: Individual component testing (KartController, KartMesh)
2. **Integration Tests**: Full kart system in isolated environment
3. **Network Tests**: Multi-player kart synchronization
4. **Performance Tests**: High-speed collision and camera behavior

## Implementation Timeline

### Week 1-2: Core Physics
- Implement KartController class
- Basic acceleration/deceleration mechanics
- Steering and angular velocity
- Ground collision detection

### Week 3: Controls and Integration
- Update input handling for kart controls
- Integrate KartController with CharacterManager
- Basic drift mechanics

### Week 4: Visual Representation
- Implement cube kart mesh
- Update Character class for kart mode
- Basic visual feedback (wheel rotation, etc.)

### Week 5-6: Camera System
- Implement dynamic follow camera
- Speed-responsive positioning
- Look-ahead prediction
- Camera stabilization

### Week 7-8: Polish and Testing
- Network synchronization updates
- Configuration system
- Testing and bug fixes
- Documentation updates

## Future Enhancements (Post-MVP)

1. **Advanced Physics**: Suspension simulation, tire grip modeling
2. **Power-ups**: Speed boosts, shields, projectiles
3. **Track Features**: Ramps, loops, boost pads
4. **Visual Effects**: Particle trails, engine sounds, tire smoke
5. **Game Modes**: Time trials, races, elimination
6. **AI Opponents**: Computer-controlled karts
7. **Track Editor**: User-generated content tools

## Risk Mitigation

### High Risk Items
1. **Physics Complexity**: Start simple, iterate towards realism
2. **Network Latency**: Implement client-side prediction
3. **Collision Detection**: Optimize for high-speed scenarios

### Mitigation Strategies
1. **Prototyping**: Build isolated prototypes before integration
2. **Feature Flags**: Allow easy rollback to character mode
3. **Performance Monitoring**: Track frame rates and network performance
4. **User Testing**: Early feedback on control responsiveness

## Conclusion

This plan provides a structured approach to converting the existing 3D web experience into a kart racing game while minimizing disruption to the existing codebase. The phased approach allows for incremental development and testing, reducing technical risk while maintaining the robust networking and rendering capabilities of the current system.

The use of feature flags and conditional logic ensures that both character and kart modes can coexist, providing flexibility for different game experiences or user preferences. 